//----------------------------------------------------------
//	Hex2Mem Microcode (c) 2021-... zpekic@hotmail.com
//  Compile with https://github.com/zpekic/MicroCodeCompiler
//----------------------------------------------------------
			.code 7, 34, hex2mem_code.mif, hex2mem_code.cgf, hex2mem_code.coe, h2m:hex2mem_code.vhd, hex2mem_code.hex, hex2mem_code.bin, 8;
			.mapper 8, 7, hex2mem_map.mif, hex2mem_map.cgf, hex2mem_map.coe, h2m:hex2mem_map.vhd, hex2mem_map.hex, hex2mem_map.bin, 1;
			.controller hex2mem_control_unit.vhd, 4;

// System interface signals
nBUSREQ			.valfield 1 values 0, 1 default 1;
nWR				.valfield 1 values 0, 1 default 1;
// nWAIT		consumed as condition
// nBUSACK		consumed as condition
// A(15..0)		
// D(7..0)

// Component interface signals
BUSY			.valfield 1 values 0, 1 default 1;
// RXD_READY	load input register on low to high transition

// Serial UART sender interface signals
// CHAR			8-bit ASCII or 0x00 if no char is to be sent
// TXDREADY		sender is ready

seq_cond:		.if 4 values 
				true, 			// hard-code to 1
				nWAIT,	 		// Z80 bus - 0 to wait for memory
				nBUSACK,		// z80 bus - 0 if CPU is 
				input_is_zero,	// do not process 0x00 input char
				TXDREADY,		// high if tracer has processed the trace character
				TXDSEND,		// will always be "1" but also generates a pulse to TXD
				-,
				-,
				-,
				-,
				-,
				-,
				-,
				-,
				-,
				false			// hard-code to 0
				default true;
seq_then:	.then 7 values next, repeat, return, fork, @ default next;				// any label
seq_else:	.else 7 values next, repeat, return, fork, 0b000000..0b111111, @ default next;	// any value as it can be a trace char
			
// contains ASCII char for UART trasmit
TXDCHAR		.regfield 4 values 
				same,
				char_input,		// to echo incoming character
				char_space,
				char_cr,
				char_lf,
				char_E,			// 'E' in "ERR"
				char_R,			// 'R' in "ERR"
				zero,
				pos0,			// bcd counter for character position in line
				pos1,
				inp0,
				inp1,			// input character
				lin0,			// bcd counter for line
				lin1,
				lin2,
				lin3
				default same;
				
// line counter 4-digit BCD
lincnt_a: 		.valfield 1 values zero, lincnt default lincnt;	// select adder "a" input, "b" is always 0
lincnt_cin:		.valfield 1 values 0, 1 default 0;			// drive carry in to increment
			
// position counter 4-digit BCD
poscnt_a: 		.valfield 1 values zero, poscnt default poscnt;	// select adder "a" input, "b" is always 0
poscnt_cin:		.valfield 1 values 0, 1 default 0;			// drive carry in to increment
			
// checksum register is currently used for address only
checksum:		.regfield 2 values
				same,
				zero,
				inc,
				-
				default same;

// control error flip-flop when generating serial output
error:			.regfield 2 values
				same,
				on,
				off,
				- 
				default same;
						
input_reset:	.valfield 1 values 0, 1 default 0;	// setting to 1 is async reset to char_input register
						
//	useful aliases, these are evaluated as simple text replacement of label with everything between .alias and ; 
goto:		.alias if false then next else;
noop:		.alias if true then next else next;
back:	    .alias if true then return else return;

// gosub aliases - this works because "jump" pushes return address to stack if both then/else are same
emit:		.alias if false then emitChar else emitChar, TXDCHAR <=;
print_err:	.alias if false then print_err else print_err;	
print_crlf:	.alias if false then print_crlf else print_crlf;	
writemem:	.alias if false then writemem else writemem;	

// other
poscnt_zero:.alias poscnt_a = zero;
lincnt_zero:.alias lincnt_a = zero;
poscnt_inc:	.alias poscnt_cin = 1;
lincnt_inc:	.alias lincnt_cin = 1;
clear:		.alias TXDCHAR <= zero, checksum <= zero, poscnt_zero, lincnt_zero, error <= off;

			.org 0;
//	First 4 microcode locations can't be used branch destinations
//	---------------------------------------------------------------------------
_reset:		clear;  

_reset1:	clear;

_reset2:	clear;

_reset3:	clear;

//	indicate availability and wait for start signal
//	---------------------------------------------------------------------------
deadloop:	BUSY = 0, if input_is_zero then repeat else next;
echo:		emit char_input;
			poscnt_inc, if true then fork else fork;

			.map 0b????????;
badchar:	error <= on, print_crlf;
			emit char_E;		// ERR
			emit char_R;
			emit char_R;
			emit char_space;
			emit lin3;			// 9999 line number (decimal)
			emit lin2;
			emit lin1;
			emit lin0;
			emit char_space;
			emit pos1;			// 99 char position in the line (decimal)
			emit pos0;
			emit char_space;
			emit inp1;			// FF hex code of offending char
			emit inp0;
			print_crlf;
nextchar:	error <= off, input_reset = 1, checksum <= inc, goto deadloop;
			
			// with mapping like this lower 4 bits of mapper can be reused as ASCII to HEX decode
			.org 0x20;
			.map '0';
			goto hexchar;
			
			.org 0x21;
			.map '1';
			goto hexchar;

			.org 0x22;
			.map '2';
			goto hexchar;

			.org 0x23;
			.map '3';
			goto hexchar;

			.org 0x24;
			.map '4';
			goto hexchar;

			.org 0x25;
			.map '5';
			goto hexchar;

			.org 0x26;
			.map '6';
			goto hexchar;

			.org 0x27;
			.map '7';
			goto hexchar;

			.org 0x28;
			.map '8';
			goto hexchar;

			.org 0x29;
			.map '9';
			goto hexchar;

			.org 0x2a;
			.map 'a';
			.map 'A';
			goto hexchar;

			.org 0x2b;
			.map 'b';
			.map 'B';
			goto hexchar;

			.org 0x2c;
			.map 'c';
			.map 'C';
			goto hexchar;

			.org 0x2d;
			.map 'd';
			.map 'D';
			goto hexchar;

			.org 0x2e;
			.map 'e';
			.map 'E';
			goto hexchar;

			.org 0x2f;
			.map 'f';
			.map 'F';
hexchar:	writemem;
			goto nextchar;

			.map 0x09;	
tab:		writemem;
			goto nextchar;
			
			.map 0x0A;
lf:			writemem;
			lincnt_inc, goto nextchar;
			
			.map 0x0D;
cr:			writemem;
			poscnt_zero, goto nextchar;

			.map ' ';
space:		writemem;
			goto nextchar;

			.map ':';
colon:		writemem;
			goto nextchar;
					
print_crlf: emit char_cr;
			emit char_lf;
			back;
			
			// "UART" is supposed to signal TDXREADY = 1 when presented 0x00 or when serial trasmit is done
//emitChar:	noop;
emitChar:	if TXDSEND then next else next;
emitChar2:	noop;
			if TXDREADY then return else repeat;
			
			
			
			// ask CPU for memory, then read 1 byte with any number of optional wait cycles
writemem:	nBUSREQ = 0;
			nBUSREQ = 0, if nBUSACK then repeat else next;
			nBUSREQ = 0, nWR = 0;
			nBUSREQ = 0, nWR = 0, if nWAIT then return else repeat;
			
